---
layout: post
title: 动态规划
date: 2021-06-30 09:37:20
tags: 动态规划
categories: 算法
---

动态规划： 「Dynamic Programming」

* [198. 打家劫舍 I](https://leetcode-cn.com/problems/house-robber/)
* [198. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber/)
* [面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/)
* [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)
* [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

以上三个问题都是 dp 的一类问题，解法也一样。
<!-- more -->
dp 的解题思路最重要的就是寻找<font color="red">「状态转移方程」</font>

状态转移方程往往依赖上一个结果的计算值：比如 [斐波那契](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/) 以及 [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

对于「斐波那契」

> f(n) = f(n - 1) + fn(n - 2)

对于「杨辉三角」(排除边界 case 1)

> dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] 

动规总能以一个数学公式进行表达

<font color="red">但 </font>这并不是动规的精髓所在，寻在「状态转移方程」往往需要寻找<font color="red">[「最优子结构」](https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.md)</font>：可以从子问题的最优结果推出更大规模问题的最优结果。

刷了一些题目之后就会发现：基本上就是从一个小规模内求一个最大最小值。「一看就会，一写就废」

以 「使用最小花费爬楼梯」为例：

1. 爬楼梯要么从第 0 步 开始，要么从 第 1 步开始。
2. 对于第 i 次解决方案而言，要么是从 i - 1 过来，要么是从 i - 2 过来。那么 dp[i] 的最优解为

`dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i]`

3. 对于结果而言，要么是从最后一步，要么是从前两步过来，因为最优的结果是：

```
Math.min(dp[dp.length - 2], dp[dp.length - 1])
```


```javascript
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  if (!cost || !cost.length) {
    return 0
  }
	let dp = []
	dp[0] = cost[0]
	dp[1] = cost[1]

	for (var i = 2; i < cost.length; i++) {
		dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i]
	}
	return Math.min(dp[dp.length - 2], dp[dp.length - 1])
}

```


